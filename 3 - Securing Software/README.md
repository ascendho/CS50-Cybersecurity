# Securing Software

## 一、课程概述
- **课程主题**：聚焦软件安全核心，涵盖常见软件攻击手段（注入攻击、伪造攻击等）、防御机制，以及软件分发与漏洞管理，核心是“不信任用户输入”和“多层防护”。
- **主讲人**：David J. Malan（哈佛大学）
- **核心目标**：理解软件漏洞的产生原理，识别注入类、伪造类攻击，掌握代码层面、架构层面的防御方法，了解软件安全生态（漏洞跟踪、赏金计划）。

## 二、常见软件攻击手段
### 1. 钓鱼攻击（Phishing）
- **原理**：通过篡改网页链接或伪造网站，欺骗用户输入敏感信息（用户名、密码）。
- **典型示例**：
  - 篡改HTML锚点标签：`"<a href='https://yale.edu'>https://harvard.edu</a>"`，显示链接为哈佛官网，实际跳转至耶鲁官网。
  - 伪造目标网站（如银行、学校登录页），诱导用户输入凭证。
- **防御关键**：鼠标悬停验证链接真实地址，不点击可疑邮件/短信中的链接，手动输入官方URL登录。

### 2. 代码注入（Cross-Site Scripting, XSS）
- **定义**：欺骗网站执行用户输入的恶意代码（多为JavaScript），利用网站对用户输入的“盲目信任”。
- **两种核心攻击类型**：
  | 攻击类型 | 原理 | 示例场景 |
  |----------|------|----------|
  | 反射型（Reflected Attack） | 恶意代码通过URL参数等方式传入，网站即时反射回页面并执行 | 诱导用户点击含恶意脚本的链接：`https://example.com/search?q=<script>alert('attack')</script>` |
  | 存储型（Stored Attack） | 恶意代码被网站存储（如评论区、邮件内容），其他用户访问时自动执行 | 在论坛评论中插入恶意脚本，所有浏览该评论的用户都会触发攻击 |
- **防御手段**：
  - 字符转义（Character Escapes）：将危险字符（`<`→`&lt;`、`>`→`&gt;`等）转换为文本格式，使恶意代码无法被解析执行。
  - HTTP安全头（Content-Security-Policy）：限制脚本/样式的加载来源，如`script-src https://example.com/`仅允许加载指定域名的.js文件，禁止页面内内嵌`<script>`标签。

### 3. SQL注入（SQL Injection）
- **原理**：用户输入的恶意SQL片段被拼接到数据库查询语句中，篡改查询逻辑，窃取或破坏数据。
- **典型示例**：
  - 场景：登录查询语句为`SELECT * FROM users WHERE username = '{username}' AND password = '{password}'`。
  - 恶意输入：密码框输入`' OR '1'='1`，拼接后查询变为`SELECT * FROM users WHERE username = 'malan' AND password = '' OR '1'='1'`，因`'1'='1`恒为真，可获取所有用户数据。
  - 破坏性输入：用户名框输入`malan'; DELETE FROM users; --`，拼接后执行`DELETE FROM users`，删除全表数据（`--`为SQL注释，忽略后续内容）。
- **防御核心**：
  - 预处理语句（Prepared Statements）：将SQL查询与用户输入分离，用户输入仅作为“数据”而非“代码”。
  - 示例：查询语句改为`SELECT * FROM users WHERE username = ?`，用户输入通过参数绑定传入，恶意字符（如`'`）会被自动转义（`'`→`''`），失效恶意逻辑。

### 4. 命令注入（Command Injection）
- **原理**：用户输入的恶意命令被传递到服务器操作系统的命令行执行，利用软件对“用户输入直接拼接命令”的漏洞。
- **高危场景**：软件使用`system`、`eval`等函数直接执行包含用户输入的命令（如文件路径、参数）。
- **防御关键**：
  - 严格净化用户输入，禁止输入中包含命令分隔符（如`;`、`&&`）。
  - 避免直接拼接用户输入到命令中，使用安全的API替代命令行调用。

### 5. 跨站请求伪造（CSRF）
- **原理**：利用用户已登录的身份（如Cookie中的会话凭证），诱导用户在第三方网站触发对目标网站的未授权操作（如购物、转账）。
- **典型示例**：
  - GET请求伪造：`<img src="https://amazon.com/dp/B07XLQ2FSK">`，浏览器自动发送购买请求（依赖GET方法处理敏感操作）。
  - POST请求伪造：第三方网站嵌入自动提交的表单，利用用户登录状态执行POST操作（如转账）。
- **防御手段**：
  - CSRF令牌（CSRF Token）：服务器为每个用户生成唯一的随机令牌，嵌入表单或HTTP头，请求时验证令牌一致性，第三方网站无法获取令牌，伪造请求失效。
  - 避免使用GET方法处理敏感操作（如购买、修改密码）。

### 6. 任意代码执行（ACE）
- **定义**：攻击者在软件中执行非预期的代码，核心漏洞为“输入超出软件限制，破坏内存结构”。
- **常见类型**：
  - 缓冲区溢出（Buffer Overflow）：输入长度远超软件预留的内存缓冲区，溢出数据覆盖其他内存区域，植入并执行恶意代码。
  - 栈溢出（Stack Overflow）：类似缓冲区溢出，针对栈内存区域，可用于破解软件授权（绕过注册验证）或反向工程。
- **防御关键**：
  - 限制输入长度，对输入进行边界检查。
  - 使用内存保护技术（如地址空间布局随机化ASLR），增加攻击难度。

## 三、软件防御核心原则与方法
### 1. 核心原则：不信任任何用户输入
- 所有用户输入（表单、URL参数、文件上传等）都可能包含恶意内容，必须经过“净化”“验证”后再使用。

### 2. 客户端与服务器端验证
- 客户端验证（如HTML的`disabled`、`required`属性）：仅用于提升用户体验，**不能作为安全防护**（用户可通过开发者工具篡改HTML，移除限制）。
- 服务器端验证：安全防护的核心，所有输入必须在服务器端再次验证（格式、长度、合法性），确保数据安全后再处理（如存入数据库、执行命令）。

### 3. 代码层面防御工具
- 字符转义：处理XSS、SQL注入的基础，自动转换危险字符。
- 预处理语句：防御SQL注入的最优方案，分离查询逻辑与用户数据。
- HTTP安全头：限制代码加载来源，防御XSS、点击劫持等。
- CSRF令牌：防御跨站请求伪造的核心机制。

## 四、软件分发与安全生态
### 1. 软件类型与安全权衡
| 软件类型 | 特点 | 安全优势 | 安全风险 |
|----------|------|----------|----------|
| 开源软件（Open-Source） | 代码公开，可被全球开发者审计 | 大量开发者参与漏洞查找，修复速度快 | 漏洞易被攻击者发现（代码透明） |
| 闭源软件（Closed-Source） | 代码不公开，仅内部团队维护 | 漏洞难以被外部攻击者发现 | 依赖内部团队审计，漏洞可能长期未被发现 |

### 2. 安全分发渠道
- 应用商店（App Stores，如Google Play、Apple App Store）：
  - 审核提交的软件，检测恶意代码。
  - 采用数字签名机制，仅允许安装经官方签名的软件，防止篡改。
- 包管理器（Package Managers）：
  - 类似应用商店，对软件包进行签名验证，确保下载的软件未被篡改。
  - 注意：仍需选择官方源，避免第三方源的恶意包。

### 3. 漏洞管理与赏金计划
- 漏洞跟踪系统：
  - CVE（Common Vulnerabilities and Exposures）：全球统一的漏洞编号体系，记录已知漏洞详情。
  - CVSS（Common Vulnerability Scoring System）：漏洞严重程度评分（如CVSS 10.0为最严重），帮助开发者优先级修复。
  - EPSS（Exploit Prediction Scoring System）：漏洞被利用的概率预测，指导防御资源分配。
  - KEV（Known Exploited Vulnerabilities）：已知被攻击者利用的漏洞列表，需紧急修复。
- 漏洞赏金计划（Bug Bounty）：
  - 企业向安全研究者付费，奖励其发现并报告软件漏洞。
  - 价值：将潜在攻击者转化为“安全守护者”，提前发现并修复漏洞，避免被恶意利用。

## 五、关键总结与注意事项
1. 软件安全的核心：不信任用户输入，所有输入必须“净化+验证”，多层防护（代码层+架构层）。
2. 注入类攻击（XSS、SQL注入、命令注入）的本质：用户输入被当作“代码”执行，防御关键是“分离代码与数据”。
3. 客户端验证不可信：必须依赖服务器端验证，客户端验证仅为体验优化。
4. 安全分发的重要性：仅通过官方应用商店、包管理器下载软件，避免安装未知来源的程序。
5. 漏洞管理是持续过程：需关注CVE、KEV等列表，及时更新软件补丁，响应高风险漏洞。